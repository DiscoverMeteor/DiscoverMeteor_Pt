---
title: Publicações e Subscrições
slug: publications-and-subscriptions
date: 0004/01/02
number: 4.5
sidebar: true
contents: Aprenda como publicações e subscrições funcionam.|Aprenda o que o pacote padrão Autopublish faz.|Veja mais alguns exemplos de padrões de publicações.
paragraphs: 52
---

Publicações e subscrições são uns dos mais importantes conceitos no Meteor, mas pode ser difícil ser difícil você entender enquanto está começando. 

Isso levou a uma série de mal-entendidos, como a crença de que o Meteor é inseguro, ou que as aplicações Meteor não podem lidar com grandes quantidades de dados.

Uma grande parcela do motivo das pessoas inicialmente acharem estes conceitos um pouco confusos é a "mágica" que o Meteor faz por nós. Embora essa mágica seja muito útil, ela pode obscurecer o que está de fato acontecendo por trás das cenas (o que uma mágica tende a fazer). Então vamos analisar as camadas dessa mágica e entender o que está acontecendo. 

### Os Velhos Tempos

Mas primeiro, vamos olhar para os bons velhos tempos em 2011 quando o Meteor ainda não havia sido lançado. Vamos dizer que você está fazendo um simples aplicativo Rails. Quando um usuário entra no site, o cliente (i.e seu navegador) manda uma requisição para sua aplicação, que está vivendo no servidor.

O primeiro trabalho da aplicação é perceber qual dado o usuário precisa de visualizar. Isso pode ser a página 12 dos resultados da busca, informação do perfil de usuário da Mary, os últimos 20 tweets de Bob, e por ai vai. Você pode nisso como sendo, basicamente, um atendente de livraria navegando entre os corredores para encontrar o livro que você pediu.

Uma vez que o dado correto tenha sido selecionado, o segundo trabalho da aplicação é traduzir este dado em um belo e legível HTML (ou JSON no caso de uma API).

Na metáfora da livraria, isso seria embrulhar o livro que você comprou em uma embalagem e colocá-lo em uma bela bolsa. Esta é a parte "View" (visão/vista) do famoso modelo Model-View-Controller (Modelo-Visão-Controlador).

Finalmente, a aplicação pega o código HTML e manda para o navegador. O trabalho da aplicação é finalizado, e agora que tudo está fora de suas mãos virtuais você pode pegar uma cerveja enquanto espera pela próxima requisição.

### O Caminho do Meteor

Vamos rever o que faz o Meteor ser tão especial em comparação. Como vimos, a principal inovação do Meteor é que enquanto aplicações Rails estão vivas apenas **no servidor**, um aplicativo Meteor inclui um componente no lado do cliente que vai rodar **no cliente** (o navegador).

<%= diagram "client-server", "Colocando um subgrupo do banco de dados no cliente.", "pull-right" %>

Isso é como um balconista que não apenas encontra o livro pra você, mas também te segue até em casa e lê o livro para você à noite (fato que vamos admitir soar um pouco assustador).

Essa arquitetura permite ao Meteor fazer várias coisas legais, principalmente com o que o Meteor chama de [database evertwhere](http://docs.meteor.com/#sevenprinciples) (banco de dados em todos os lugares). Simplesmente,  Meteor vai pegar uma parte do seu banco de dados e *copiá-lo para o cliente*.

Isso tem duas grandes implicações: primeira, ao invés de mandar código HTML para o cliente, a aplicação Meteor vai mandar **o real, dado puro** e o cliente vai lidar com ele ([data on the wire](http://docs.meteor.com/#sevenprinciples) - dado na rede). Segundo, você vai ser capaz de **acessar o dado instantaneamente** sem ter que esperar por uma ida e volta do servidor ([latency compensation](http://docs.meteor.com/#sevenprinciples) - compensação de latência).

### Publicação

O banco de dados de um aplicativo pode conter dez mil documentos, sendo alguns destes privados ou sensíveis. Então obviamente não devemos simplesmente espelhar nosso banco de dados completamente no cliente, por razões de segurança e escabilidade.

Então vamos precisar de uma forma de dizer ao Meteor quais **subgrupos** de dados podem ser enviados ao cliente, e vamos realizar isso através de uma **publicação**. 

Vamos voltar ao Microscope. Aqui estão todos os posts do no aplicativo situados no banco de dados:

<%= diagram "collections-1", "Todos os posts contidos no nosso banco de dados.", "pull-center" %>

Embora esse recurso reconhecidamente não exista no Microscope, vamos imaginar que alguns de nossos posts tenham sido marcados por linguagem abusiva. Mesmo que queiramos que eles continuem em nosso banco de dados, eles não devem estar disponíveis para os usuários (i.e enviados ao cliente).

Nossa primeira tarefa vai ser dizer ao Meteor qual dado nós **vamos** querer enviar ao cliente. Vamos dizer ao Meteor que desejamos **publicar** apenas os posts sem marcações:

<%= diagram "collections-2", "Excluindo posts marcados.", "pull-center" %>

Aqui temos o código correspondente, que deve estar no servidor:

~~~js
// no servidor
Meteor.publish('posts', function() {
  return Posts.find({flagged: false});
});
~~~

Isso assegura para que **não exista uma forma** de um cliente estar apto a acessar post marcados. Isso é exatamente a forma que você torna uma aplicação Meteor segura: apenas assegure-se de publicar dados que você queira que estejam disponíveis para acesso no cliente.

<% note do %>

### DDP

Fundamentalmente, você pode pensar sobre o sistema de publicação/subscrição como um funil que transfere dados de uma coleção no lado do servidor para uma coleção no lado do cliente.  

O protocolo que é utilizado neste funil é chamado **DDP** (que significa Distributed Data Protocol - Protocolo de Dados Distribuidos). Para aprender mais sobre DDP, você pode assistir [essa palestra da *Real-Time Conference*](http://2012.realtimeconf.com/video/matt-debergalis) por Matt DeBergalis (um dos fundadores do Meteor), ou [este screencast](http://www.eventedmind.com/posts/meteor-subscriptions-and-ddp) por Chris Mather que conduz você por este conceito com um pouco mais de detalhe.

<% end %>

### Subscribing

////

////

////

<%= diagram "collections-3", "Subscribing to Bob's posts will mirror them on the client.", "pull-center" %>

////

~~~js
// on the server
Meteor.publish('posts', function(author) {
  return Posts.find({flagged: false, author: author});
});
~~~

////

~~~js
// on the client
Meteor.subscribe('posts', 'bob-smith');
~~~

////

### Finding

////

<%= diagram "collections-4", "Selecting a subset of documents on the client.", "pull-center" %>

////

~~~js
// on the client
Template.posts.helpers({
  posts: function(){
    return Posts.find(author: 'bob-smith', category: 'JavaScript');
  }
});
~~~

////

### Autopublish

////

////

<%= diagram "autopublish", "Autopublish", "pull-center"%>

////

////

////

### Publishing Full Collections

////

~~~js
Meteor.publish('allPosts', function(){
  return Posts.find();
});
~~~

<%= diagram "fullcollection", "Publishing a full collection", "pull-center" %>

////

### Publishing Partial Collections

////

~~~js
Meteor.publish('somePosts', function(){
  return Posts.find({'author':'Tom'});
});
~~~

<%= diagram "partialcollection", "Publishing a partial collection", "pull-center" %>

<% note do %>

### Behind The Scenes

////

////

////

////

- ////
- ////
- ////

////

<% end %>

### Publishing Partial Properties

////

////

~~~js
Meteor.publish('allPosts', function(){
  return Posts.find({}, {fields: {
    date: false
  }});
});
~~~

<%= diagram "partialproperties", "Publishing partial properties", "pull-center" %>

////

~~~js
Meteor.publish('allPosts', function(){
  return Posts.find({'author':'Tom'}, {fields: {
    date: false
  }});
});
~~~

### Summing Up

////

////

////
